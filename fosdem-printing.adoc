= Why our HTML Docs don't just `Print` andÂ what to do about it
:!imagesdir:
:source-highlighter: rouge
// :rouge-css: style
:revealjsdir: reveal.js
:revealjs_customtheme: white-course.css
:revealjs_slideNumber:
:revealjs_history:
:revealjs_progress:
:revealjs_mouseWheel: true
:revealjs_center: false
:revealjs_transition: none
:revealjs_width: 1600
:revealjs_height: 900
:icons: font
:figure-caption!:
:example-caption!:
:table-caption!:
:sectnums:

[.title-footer]
[cols="260,1100,320"]
// tag::asciidoc-title-table[]
|===
a|
[.title-photo]
image::images/nmp1.jpg[]
a|
[.full-name]
Nikolaj Potashnikov

[.bio]
PhD in Economics, Solution architect, Course-IT
.2+>.>a|{nbsp}
[.logo]
image::images/fosdem-logo.svg[]
2+a|
[.contact]
icon:envelope[] consulting@yandex.ru icon:telegram[]{nbsp}@nmpotashnikoff
|===
// end::asciidoc-title-table[]

[.notes]
--
* As a solution architect I need to create targeted docs for each stakeholder.
What is the easiest way to share them?
Via email, messenger... as a PDF, a Word file.
In short, in a 'print' format.
--

[[a300]]
== Way in converting simple text markup to `print` formats

* https://github.com/CourseOrchestra/course-doc: XSL-FO templates for Asciidoctor -> Docbook backend
* https://github.com/CourseOrchestra/asciidoctor-open-document: Open Document Converter for Asciidoc
* https://github.com/fiddlededee/unidoc-publisher: UniDoc Publisher -- any markup to any printing rendering engine

[.notes]
--
* Today we are speaking about UniDoc Publisher approach, but we'll look at Asciidoctor Open Document. Why despite success I felt obliged to make an extra step.
--

[[a1]]
== `Print`, `Export to Word`, `Export to PDF` are very often just a trap

[%step]
.What to do with long line in listing?
* We may scale
* Or use landscape orientation
* Or both, but would it be enough?
* If not, we may fire error for long lines
* Or wrap them
* With linefeed and spaces?
And how to copy?
* With indents?
Still impossible to copy from PDF

[%step]
TIP: And in web we can just add horizontal scroll bar.

[.notes]
--
* There is the core mismatch: semantic markup meets the rigid world of print.
* Take a simple listing... (go through very briefly just to give filling)
** Stop on orientation -- it is already not about semantic markup. Landscape for listing, for section, for higher level section?
Should tech writer use media hints?
* My goal for today is to show my approach to for tackling such problems UniDoc Publisher
--

[[a17]]
== Main formats for printing

[%step]
. PDF
. Text processing formats (Open XML -- MS Office, Open Document -- LibreOffice)
. HTML?

[%step]
[TIP]
CSS Paged Media -- CSS extension, defining style specific for printing

[.notes]
--
* Despite we live with Paged Media CSS for almost 15 years, HTML -- still poor browser support, usually used via PDF. HTML for printing is intermediary format. There is a great open source solutions to convert it to PDF -- WeasyPrint and a number of a very good non opensource solutions. But still HTML is an intermediary format
* If somebody interested, probably most well-known are Antenna Publisher, Oxygen (the letter we used 20 years ago for authoring DocBook and converting to PDF via TeX)
--

[[a2]]
=== Most widespread rendering approaches

[%step]
* PDF <- native PDF-generating libraries
* PDF <- XSL-FO with FOP-processors
* PDF <- via TeX
* PDF <- HTML + Paged Media CSS
* DOCX/ODT, PDF <- +/- text processors (MS Word, LO Writer)

[%step]
[WARNING]
====
These technologies are not aligned in infinite details like:

* Apache FOP has problems with Leader alignment (dots in a table of contents)
* LO Writer doesn't support typography (like keep with next) within table cells
* Microsoft doesn't recommend to run automation tasks (like saving PDF) on a server
====


[.notes]
--
* There are others, but I estimate these as 99% of all
* You can see Leader Problems in UniDoc Publisher documentation
* Native libraries examples: ReportLab in Python, Prawn in Ruby, PDFBox in Java
* (if somebody needs reference) https://support.microsoft.com/en-us/topic/considerations-for-server-side-automation-of-office-48bcfe93-8a89-47f1-0bce-017433ad79e2
--

== Some brief conclusions

[%step]
[WARNING]
====
Feel like speleologist?
====

[%step]
--
[%step]
* The world of printing is the world of constraints
* And that constraints differ for each technology, you often need to support several chains (exquisitely looking PDF with TeX and LibreOffice for coordination)
* With no universal solutions
--

[.notes]
--
Two speleologist meet in a narrow tunnel.
I'm from a dead end.
I'm too!

* Documentation of UniDoc Publisher is created with Asciidoctor is published with WeasyPrint, XSL-FO and Open Document toolchains. Looks pretty the same. But just as a proof of concept
--

[[a50]]
== UniDoc Publisher approach suits best if at least `one of`

* You don't prepare documentation especially for printing purposes
* You are automating documentation generation and hope it will look good, no matter what will be generated
* You output format is one of text processing format

[.notes]
--
* First point is usually true if inputs -- Simple markup/Wiki, main means of publication -- HTML or static site
--

[[a9]]
== In search for flexibility: Asciidoctor open document

.Automation on the writer side
--
[%step]
. Asciidoctor parses markup into AST (Abstract Syntax Tree)
. You may transform AST with Asciidoctor AST processing
. Asciidoctor runs writer template for each AST node recursively
. You may write you code in pure Ruby or with special Slim templates
--


[.notes]
--
* First idea was to follow Asciidoctor ways, and these proved to be working ways
--

[[a301]]
=== A simplified processing AST example

[cols="2,3"]
|===
a|
[source, yaml, indent=0]
----
      - !<OrderedList>
        roles:
        - "arabic"
        id: "ol-1"
        captioned_title:
            children:
            - !<Text>
              text: "Automation"
        children:
        - !<ListItem>
          children:
          - !<Paragraph>
            children:
            - !<Text>
              text: "Asciidoctor..."
        - !<ListItem>
      ...
----

a|
[source,slim]
----
- list_style = "#{get_basic_style}"
- if captioned_title?
  text:p text:style-name="#{list_style}"
    text:bookmark text:name="#{id}"
    =captioned_title

text:list text:style-name="#{list_style}"
  - items.each_with_index do \|item, index\|
----
|===

[.notes]
--
* dash means code in Ruby
* get_basic_style -- is some external function, defined as a helper, so Ruby can be used withing template
--

[[a10]]
=== Great, but

[%step]
* You can't override part of a template
* You should invent styling approach

[%step.indent-before]
.Styling? But text processors do support styling!
--
[WARNING]
====
[%step]
* `<span class="bold green">bold, green</span>` -- impossible to apply two styles to one element
====
--

[%step]
[TIP]
====
* Asciidoctor Open Document introduces some extended Open Document format to preserve Asciidoctor AST contents
* Each function checks, if style should be applied, and if yes, applies it
====

[.notes]
--
* In text processors we can't apply two styles, so we can't leave styling to text processor template
* This extended format resembles AST itself
--

[[a11]]
=== And still

[%step]
* Unexpectedly transforming this extended Open Document format became one of the most used feature of Asciidoctor Open Document
* Styling as separate task of writing proved also to be useful
* The Gradle was magnificent in gluing all parts together

[.notes]
--
* But we have example of Pandoc that places heavy attention on AST transformation.
There is even https://github.com/jgm/pandocfilters[pandocfilter] project, that simplifies AST transformation for Python. I think the world meta-converter quite fits Pandoc. But using own converters raises compatibility issues and no special styling approach.
* Although this circus is glued with docker, my experiments showed, that gluing with Gradle is much more controllable. Yes, finally it would be docker. but at the very end
--

[[a12]]
== Thoughts before the second step

[%step]
* If creating universal converter impossible...
* We should create meta converter -- platform for building converters

[%step.indent-before]
.Estimated requirements
--
[%step]
* Native converter as a reader
* Great ways of transforming AST
* A good approach for styling as a separate focus
* 99% generic writer
* Good integration with CI/CD
--

[[a200]]
== Native converter as a reader?

[%step]
TIP: Each converter outputs HTML.
HTML is quite semantic, why shouldn't we use it?

[[a105]]
== Let's convert this presentation to LO Writer

image::images/slide-1-to-print.png[width=65%]

[.notes]
--
This presentation as is shown in Ivan Ponomarev talk is created with Asciidoctor, so we can convert it to document with notes
--

[[a306]]
== Notes on this demo

[%step]
* Everything is in a single `build.gradle.kts` file
* All Kotlin code examples are just includes from this `build.gradle.kts`

[[a106]]
== Boilerplate

[source,kotlin,indent=0]
----
include::build.gradle.kts[tag=boiler-plate]
                // Processing AST
include::build.gradle.kts[tag=boiler-plate-2]
----

[.notes]
--
.Just stress
* That Asciidoctor is a part of a gradle build
* I started not from Asciidoctor HTML, but from Reveal.js Asciidoctor HTML to make notes more close to it and as a proof of constant, that technology have a safety margin against any HTML: Asciidoc HTML, Asciidoc Reveal.js HTML, MD, Wiki, ReST...
* And that it is quite minimalistic
--

[[a107]]
== Processing AST

[source,kotlin,indent=0]
----
include::build.gradle.kts[tag=orchestration-rebuild-title]
----

[.notes]
--
Stress, that this is typical AST transforming code. Find nodes, and do smth with them.

Here we find section with H1 heading (title slide), and insert before it transformed version, then remove old version
--

[[a108]]
== Rearranging title (Asciidoc source)

[source,asciidoc]
----
include::fosdem-printing.adoc[tag=asciidoc-title-table]
----

[.notes]
--
Stress that all elements has roles
--

[[a109]]
== Rearranging title, extracting semantics

[source,kotlin,indent=0]
----
include::build.gradle.kts[tag=extracting-title-element]
----

[.notes]
--
* stress that extracting looks like Xpath
--

[[a110]]
== Rearranging title, constructing title

[source,kotlin,indent=0]
----
include::build.gradle.kts[tag=building-new-title]
----

[.notes]
--
Rearranging looks like slim (or XSLT) templates. Not so slim as Slim, but definitely slimmer than XSLT
--

[[a309]]
== Let's return to the result

image::images/print-title.png[width=55%]

[[a201]]
== And a little bit of styling

[source,kotlin,indent=0]
----
include::build.gradle.kts[tag=title-page-styles]
----

[.notes]
--
Not a CSS, but the feeling resembles: select node, apply formatting
--

[[a112]]
== Let's return to processing AST

[source,kotlin,indent=0]
----
include::build.gradle.kts[tag=orchestration-other]
----

[.notes]
--
<1> Inserting horizontal lines before notes
<2> Preventing slide from breaking
<3> Applying custom style and rouge code highlighting styles
--

[[a113]]
== Extending AST

[%step]
[source,kotlin,indent=0]
----
include::build.gradle.kts[tag=defining-custom-element]
----

[.notes]
--
Extending AST is quite simple. But it is rarely used. This is artificial example, easier solution would be to add paragraph directly
--

[%step]
[source,kotlin,indent=0]
----
include::build.gradle.kts[tag=custom-element]
----

[[a14]]
=== Testing

image::images/approval.png[width=100%]

[.notes]
--
If we have Asciidoctor with some Printing converter platform on top and Converter on top, we should be sure, that minor changes won't break anything.

I use the system of snippets, render them into png and compare by pixels with reference.
Almost 100% guaranty.

By the way these snippets can be put into documentation.
These are real cases.

But it is already Ivan Ponomarev talk
--

== Conclusion

[%step]
* If you need to get doc in printing format, don't pursue universality, limit, limit and limit
* Don't search for solution with options, prepare to code
* Ecosystem is crucial. Gradle + Kotlin stack is just a coincidence, where syntax, wide ecosystem and CI accidentally met
* Still more coincidence, they met Asciidoctor
* Still more coincidence, they met LibreOffice API
* Too much coincidence for coincidence?

[.notes]
--
* There are slides with comparison, we can look at them personally after the talk
--

== Questions?

// Here QR code to Asciidoctor Open Document and UniDoc Publisher repositories

//Bonus slides: rendering technology comparison
// Not to be shown during talk: for questions and discussions
[%notitle]
== Bonus slides

[[a20]]
=== Comparison

[options=header,cols="1,3,4"]
|===
|Technology |Strengths |Weaknesses
|Native
a|* The technology is typically used by converters with a low entry barrier
a|* Most often has a unique configuration approach
* High likelihood of encountering unexpected limitations

|XSL-FO
a|* Time-tested technology, W3C standard
a|* Different processors yield different results (e.g., varying typography limitations)
* Better to stick to FO; XSLT is outdated and hard to maintain
* Slow build performance (at least with Apache FOP)

|===

[[a18]]
== Comparison #2

[options=header,cols="1,3,4"]
|===
|Technology |Strengths |Weaknesses
|TeX
a|* Best-in-class typography, suitable for mass printing
* Mature, albeit complex, ecosystem
a|* ...albeit complex ecosystem
|Paged Media CSS
a|* W3C standard
* Takes HTML as input, so it's practically applicable everywhere
a|* Browser support remains very limited
* Among free tools, I would recommend only WeasyPrint

|===

[[a19]]
== Comparison #3

[options=header,cols="1,3,4"]
|===
|Technology |Strengths |Weaknesses
|Word processors
a|* Format is designed for manual editing of the output document
* Fastest way to produce output (even when PDF is required)
a|* Only LibreOffice aligns with the DocOps paradigm
* Imposes numerous constraints, including on typography
* Saving to a word processor format almost always requires extensive custom adjustments and limitations
|===

